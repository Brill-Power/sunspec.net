/*
 * Copyright (c) 2024-2025 Brill Power.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SunSpec.Models.Generation;

[Generator]
public class ModelGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var pipeline = context.AdditionalTextsProvider
            .Where(static (file) => Path.GetFileName(file.Path).StartsWith("model"))
            .Select(static (model, cancellationToken) =>
            {
                string path = model.Path;
                ModelCompiler.TryGenerate(model.Path, out ushort? modelId, out string? className, out string? code);
                return (path, modelId, className, code);
            })
            .Where(static (pair) => !String.IsNullOrEmpty(pair.code))
            .Collect();

        context.RegisterSourceOutput(pipeline,
            static (context, models) =>
            {
                using (StringWriter writer = new StringWriter())
                {
                    WriteHeader(writer);
                    writer.WriteLine("public class SunSpecAnyModelBuilder");
                    writer.WriteLine("{");
                    writer.WriteLine("\tpublic static ISunSpecModel Create(int modelId, Memory<byte> buffer)");
                    writer.WriteLine("\t{");
                    writer.WriteLine("\t\tswitch (modelId)");
                    writer.WriteLine("\t\t{");
                    foreach ((string path, ushort? modelId, string? className, string? code) in models)
                    {
                        string newName = Path.GetFileName(path).Replace(".json", ".generated.cs");
                        context.AddSource(newName, SourceText.From(code!, Encoding.UTF8));
                        writer.WriteLine($"\t\t\tcase {modelId}:");
                        writer.WriteLine($"\t\t\t\treturn {className}.Create(buffer);");
                    }
                    writer.WriteLine("\t\t\tdefault:");
                    writer.WriteLine("\t\t\t\tthrow new KeyNotFoundException($\"No model found for ID {modelId}.\");");
                    writer.WriteLine("\t\t}");
                    writer.WriteLine("\t}");
                    writer.WriteLine("}");
                    writer.Flush();
                    context.AddSource("SunSpecAnyModelBuilder.generated.cs", SourceText.From(writer.ToString(), Encoding.UTF8));
                }
            });
    }

    private static void WriteHeader(StringWriter writer)
    {
        writer.WriteLine("// This code has been generated by a tool.");
        writer.WriteLine("// Do not modify it. Your changes will be overwritten.");
        writer.WriteLine("using System;");
        writer.WriteLine("using System.Collections.Generic;");
        writer.WriteLine("using System.ComponentModel;");
        writer.WriteLine("using System.ComponentModel.DataAnnotations;");
        writer.WriteLine("using System.Text;");
        writer.WriteLine("using System.Buffers.Binary;");
        writer.WriteLine();
        writer.WriteLine("namespace SunSpec.Models.Generated;");
        writer.WriteLine();
    }

    private class ModelCompiler
    {
        private static readonly Regex InvalidCharacters = new Regex("[^A-Za-z0-9]", RegexOptions.Compiled);

        public static bool TryGenerate(string path, [NotNullWhen(true)] out ushort? modelId, [NotNullWhen(true)] out string? className, [NotNullWhen(true)] out string? result)
        {
            try
            {
                using (FileStream stream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (StringWriter writer = new StringWriter())
                using (StringWriter builderWriter = new StringWriter())
                using (StringWriter appendixWriter = new StringWriter())
                {
                    Model? model = Model.GetModel(stream);
                    if (model is null)
                    {
                        throw new ArgumentException($"Could not load SunSpec mode from file {path}.");
                    }

                    if (model.Label?.Contains("DEPRECATED", StringComparison.InvariantCultureIgnoreCase) ?? false)
                    {
                        className = default;
                        modelId = default;
                        result = default;
                        return false;
                    }

                    modelId = model.ID;
                    className = ConvertName(model.Group.Name, true);
                    if (className.EndsWith("Model"))
                    {
                        className = className.Substring(0, className.Length - 5);
                    }

                    WriteHeader(writer);
                    if (!String.IsNullOrEmpty(model.Group.Description ?? model.Group.Label))
                    {
                        writer.WriteLine("/// <summary>");
                        writer.WriteLine($"/// {model.Group.Description ?? model.Group.Label}");
                        writer.WriteLine("/// </summary>");
                        writer.WriteLine($"[Description(\"{model.Group.Description ?? model.Group.Label}\")]");
                    }
                    writer.WriteLine($"public class {className} : ISunSpecModel<{className}>");
                    writer.WriteLine("{");
                    writer.WriteLine("\tprivate readonly Memory<byte> _buffer;");
                    writer.WriteLine();
                    writer.WriteLine($"\tpublic static {className} Create(Memory<byte> buffer)");
                    writer.WriteLine("\t{");
                    writer.WriteLine($"\t\treturn new {className}(buffer);");
                    writer.WriteLine("\t}");
                    writer.WriteLine();

                    // find count names
                    HashSet<string> countNames = [];
                    foreach (Group group in model.Group.Groups)
                    {
                        if (group.Count is string s && !String.IsNullOrEmpty(s))
                        {
                            countNames.Add(s);
                        }
                    }

                    int offset = ProcessPoints(className, model.Group.Points, countNames, writer, appendixWriter, out Dictionary<string, string> pointNames, out bool hasScaleFactors);

                    List<string> groupNames = [];
                    Dictionary<string, string?> countReferences = [];
                    foreach (Group group in model.Group.Groups)
                    {
                        string groupName = ConvertName(group.Name, true);
                        if (!groupName.StartsWith(className))
                        {
                            // ensure unique
                            groupName = className + groupName;
                        }

                        groupNames.Add(groupName);
                        // property which gives number of elements in group
                        string? countReference = group.Count as string;
                        if (!String.IsNullOrEmpty(countReference) && pointNames.TryGetValue(countReference, out string? pointName))
                        {
                            countReferences.Add(groupName, pointName);
                        }
                        if (!String.IsNullOrEmpty(group.Description ?? group.Label))
                        {
                            appendixWriter.WriteLine("/// <summary>");
                            appendixWriter.WriteLine($"/// {group.Description ?? group.Label}");
                            appendixWriter.WriteLine("/// </summary>");
                            appendixWriter.WriteLine($"[Description(\"{group.Description ?? group.Label}\")]");
                        }
                        appendixWriter.WriteLine($"public class {groupName}"); // begin class
                        appendixWriter.WriteLine("{");
                        appendixWriter.WriteLine("\tprivate readonly Memory<byte> _buffer;");
                        if (hasScaleFactors)
                        {
                            appendixWriter.WriteLine($"\tprivate readonly {className}ScaleFactors ScaleFactors;");
                        }
                        appendixWriter.WriteLine();
                        appendixWriter.Write($"\tprivate {groupName}(Memory<byte> buffer");
                        if (hasScaleFactors)
                        {
                            appendixWriter.Write(", ");
                            appendixWriter.Write(className);
                            appendixWriter.Write("ScaleFactors scaleFactors");
                        }
                        appendixWriter.WriteLine(")");
                        appendixWriter.WriteLine("\t{");
                        appendixWriter.WriteLine("\t\t_buffer = buffer;");
                        if (hasScaleFactors)
                        {
                            appendixWriter.WriteLine("\t\tScaleFactors = scaleFactors;");
                        }
                        appendixWriter.WriteLine("\t}");
                        appendixWriter.WriteLine();
                        appendixWriter.Write($"\tpublic static {groupName} Create(Memory<byte> buffer");
                        if (hasScaleFactors)
                        {
                            appendixWriter.Write(", ");
                            appendixWriter.Write(className);
                            appendixWriter.Write("ScaleFactors scaleFactors");
                        }
                        appendixWriter.WriteLine(")");
                        appendixWriter.WriteLine("\t{");
                        appendixWriter.Write($"\t\treturn new {groupName}(buffer");
                        if (hasScaleFactors)
                        {
                            appendixWriter.Write(", scaleFactors");
                        }
                        appendixWriter.WriteLine(");");
                        appendixWriter.WriteLine("\t}");
                        using (StringWriter appendixAppendixWriter = new StringWriter())
                        {
                            int groupOffset = ProcessPoints(groupName, group.Points, new HashSet<string>(), appendixWriter, appendixAppendixWriter, out _, out bool hasGroupScaleFactors);
                            if (hasGroupScaleFactors)
                            {
                                throw new NotSupportedException("Scale factors on groups are not currently supported.");
                            }
                            appendixWriter.WriteLine();
                            appendixWriter.WriteLine($"\tpublic UInt16 Length => {groupOffset};");
                            appendixWriter.WriteLine("}"); // end class groupName
                            appendixWriter.WriteLine();
                            appendixWriter.WriteLine(appendixAppendixWriter.ToString());
                        }
                        // backing field and read-only property to access group elements in main class
                        writer.WriteLine();
                        writer.WriteLine($"\tprivate readonly List<{groupName}> _{ToFieldName(groupName)}s = new List<{groupName}>();");
                        writer.WriteLine();
                        writer.WriteLine($"\tpublic IReadOnlyList<{groupName}> {groupName}s => _{ToFieldName(groupName)}s;");
                    }

                    writer.WriteLine();
                    writer.WriteLine("\tpublic UInt16 Length");
                    writer.WriteLine("\t{");
                    // length value on wire is always 2 less as it doesn't include ID or length registers
                    writer.WriteLine("\t\tget { return (ushort)(BinaryPrimitives.ReadUInt16BigEndian(_buffer.Span.Slice(2)) + 2); }");
                    writer.WriteLine("\t\tprivate set { BinaryPrimitives.WriteUInt16BigEndian(_buffer.Span.Slice(2), (ushort)(value > 2 ? value - 2: value)); }");
                    writer.WriteLine("\t}");
                    writer.WriteLine();
                    foreach (string groupName in groupNames)
                    {
                        writer.WriteLine($"\tpublic {groupName} Add{groupName}()");
                        writer.WriteLine("\t{");
                        writer.Write($"\t\t{groupName} item = {groupName}.Create(_buffer.Slice(Length)");
                        if (hasScaleFactors)
                        {
                            writer.Write(", ScaleFactors");
                        }
                        string listName = $"_{ToFieldName(groupName)}s";
                        writer.WriteLine(");");
                        writer.WriteLine($"\t\t{listName}.Add(item);");
                        writer.WriteLine($"\t\tLength += item.Length;"); // update total length of this object
                        if (countReferences.TryGetValue(groupName, out string? countReference))
                        {
                            writer.WriteLine($"\t\t{countReference} = (UInt16){listName}.Count;"); // update count
                        }
                        writer.WriteLine("\t\treturn item;");
                        writer.WriteLine("\t}");
                        writer.WriteLine();
                    }

                    // constructor, etc.
                    if (hasScaleFactors)
                    {
                        writer.WriteLine($"\tpublic {className}ScaleFactors ScaleFactors {{ get; }}");
                        writer.WriteLine();
                    }
                    writer.WriteLine($"\tprivate {className}(Memory<byte> buffer)");
                    writer.WriteLine("\t{");
                    writer.WriteLine("\t\t_buffer = buffer;");
                    if (hasScaleFactors)
                    {
                        writer.WriteLine($"\t\tScaleFactors = new {className}ScaleFactors(buffer);");
                    }
                    writer.WriteLine("\t\tBinaryPrimitives.WriteUInt16BigEndian(_buffer.Span, ID);");
                    writer.WriteLine($"\t\tLength = {offset};");
                    // if this is being initialised with data retrieved from another server
                    // we need to populate lists of repeating groups
                    foreach (string groupName in groupNames)
                    {
                        if (countReferences.TryGetValue(groupName, out string? countReference))
                        {
                            string countName = $"{ToFieldName(groupName)}Count";
                            writer.WriteLine($"\t\tushort? {countName} = {countReference};"); // copy as add method will overwrite
                            writer.WriteLine($"\t\tfor (int i = 0; i < {countName}; i++)");
                            writer.WriteLine("\t\t{");
                            writer.WriteLine($"\t\t\tAdd{groupName}();");
                            writer.WriteLine("\t\t}");
                        }
                    }
                    writer.WriteLine("\t}");

                    writer.WriteLine("}");
                    writer.WriteLine();

                    // now make the factory
                    builderWriter.WriteLine($"public class {className}Builder : ISunSpecModelBuilder<{className}>");
                    builderWriter.WriteLine("{");
                    builderWriter.WriteLine("#nullable enable");
                    builderWriter.WriteLine($"\tprivate {className}? _model;");
                    builderWriter.WriteLine("#nullable disable");
                    List<string> fieldNames = groupNames.Select(ToFieldName).ToList();
                    foreach (string fieldName in fieldNames)
                    {
                        builderWriter.WriteLine($"\tprivate int _{fieldName}Count;");
                    }
                    builderWriter.WriteLine();
                    builderWriter.WriteLine("#nullable enable");
                    builderWriter.WriteLine($"\tpublic {className} Model => _model!;");
                    builderWriter.WriteLine("#nullable disable");
                    builderWriter.WriteLine();
                    for (int i = 0; i < groupNames.Count; i++)
                    {
                        builderWriter.WriteLine($"\tpublic void Add{groupNames[i]}()");
                        builderWriter.WriteLine("\t{");
                        builderWriter.WriteLine($"\t\t_{fieldNames[i]}Count++;");
                        builderWriter.WriteLine("\t}");
                        builderWriter.WriteLine();
                    }
                    builderWriter.WriteLine("\tpublic bool Build(Memory<byte> buffer, out int length, out ISunSpecModel model)");
                    builderWriter.WriteLine("\t{");
                    builderWriter.WriteLine($"\t\t_model = {className}.Create(buffer);");
                    builderWriter.WriteLine("\t\t_model.Initialise();");
                    for (int i = 0; i < groupNames.Count; i++)
                    {
                        builderWriter.WriteLine($"\t\tfor (int i = 0; i < _{fieldNames[i]}Count; i++)");
                        builderWriter.WriteLine("\t\t{");
                        builderWriter.WriteLine($"\t\t\t{groupNames[i]} child = Model.Add{groupNames[i]}();");
                        builderWriter.WriteLine("\t\t\tchild.Initialise();");
                        builderWriter.WriteLine("\t\t}");
                    }
                    builderWriter.WriteLine("\t\tlength = Model.Length;");
                    builderWriter.WriteLine("\t\tmodel = Model;");
                    builderWriter.WriteLine("\t\treturn true;");
                    builderWriter.WriteLine("\t}");
                    builderWriter.WriteLine("}");

                    writer.Flush();
                    appendixWriter.Flush();
                    result = writer.ToString() + appendixWriter.ToString() + builderWriter.ToString();
                    return true;
                }
            }
            catch (Exception ex)
            {
                throw new ArgumentException($"Unable to transform {path}: {ex.Message}", ex);
            }
        }

        private static int ProcessPoints(string className, IReadOnlyList<Point> points, ISet<string> countNames, TextWriter writer, TextWriter appendixWriter, out Dictionary<string, string> pointNames, out bool hasScaleFactors)
        {
            hasScaleFactors = false;
            Dictionary<int, string> writeablePointNamesByOffset = [];
            List<string> nullableProperties = [];
            List<int> paddingOffsets = [];
            Dictionary<string, List<string>> appendicesByTypeName = new Dictionary<string, List<string>>();
            pointNames = new Dictionary<string, string>(); // used to check for unique names (because we usually derive from label)
            List<(Point, int)> scaleFactors = new List<(Point, int)>();
            int offset = 0;
            ushort modelId;
            foreach (Point point in points)
            {
                int currentOffset = offset;
                offset += point.Size;

                // special case for ID and length
                if (point.Name == "ID" && point.Value is not null && point.IsStatic)
                {
                    modelId = ((JsonElement)point.Value!).GetUInt16();
                    writer.WriteLine($"\tpublic UInt16 ID => {modelId};");
                    continue;
                }
                else if (point.Name == "L")
                {
                    continue;
                }

                // special case for scale factors
                if (point.Type == PointType.SunSsf)
                {
                    hasScaleFactors = true;
                    scaleFactors.Add((point, currentOffset));
                    continue;
                }

                // concoct a name
                string pointName = InvalidCharacters.Replace(point.Label ?? point.Name, String.Empty);
                if (pointNames.ContainsValue(pointName))
                {
                    // think we can assume name is unique
                    pointName = InvalidCharacters.Replace(point.Name, String.Empty);
                }
                pointNames.Add(point.Name, pointName);

                string clrType;
                string? readMethod = null;
                string? writeMethodFormat = null;
                string scaler = String.Empty;
                string descaledValue = "value";
                if (!String.IsNullOrEmpty(point.ScaleFactor))
                {
                    string scale = $"ScaleFactors.{point.ScaleFactor.Replace("_SF", String.Empty)}";
                    scaler = $" * {scale}";
                    descaledValue = $"(value / {scale})";
                }
                switch (point.Type)
                {
                    case PointType.UInt16:
                    case PointType.UInt32:
                    case PointType.UInt64:
                    case PointType.Int16:
                    case PointType.Int32:
                    case PointType.Int64:
                        clrType = point.Type.ToString();
                        readMethod = $"SunSpecNullablePrimitives.Read{point.Type}BigEndian";
                        writeMethodFormat = $"SunSpecNullablePrimitives.Write{point.Type}BigEndian({{0}}, ({clrType}{{1}}){descaledValue})";
                        break;
                    case PointType.Bitfield16:
                    case PointType.Bitfield32:
                    case PointType.Bitfield64:
                        // need to make an enum
                        clrType = $"{className}{pointName}";
                        if (!TryCreateEnum(point, pt => pt switch
                        {
                            PointType.Bitfield16 => "UInt16",
                            PointType.Bitfield32 => "UInt32",
                            PointType.Bitfield64 => "UInt64",
                            _ => null
                        }, "1 << {0}", appendicesByTypeName, ref clrType, out readMethod, out writeMethodFormat))
                        {
                            continue;
                        }
                        if (appendicesByTypeName.TryGetValue(clrType, out List<string>? lines))
                        {
                            lines.Insert(0, "[Flags]");
                        }
                        break;
                    case PointType.Enum16:
                    case PointType.Enum32:
                        clrType = $"{className}{pointName}";
                        if (!TryCreateEnum(point, pt => pt switch
                        {
                            PointType.Enum16 => "UInt16",
                            PointType.Enum32 => "UInt32",
                            _ => null
                        }, "{0}", appendicesByTypeName, ref clrType, out readMethod, out writeMethodFormat))
                        {
                            continue;
                        }
                        break;
                    case PointType.Float32:
                        clrType = "float";
                        readMethod = "SunSpecNullablePrimitives.ReadSingleBigEndian";
                        writeMethodFormat = $"SunSpecNullablePrimitives.WriteSingleBigEndian({{0}}, ({clrType}{{1}}){descaledValue})";
                        break;
                    case PointType.Float64:
                        clrType = "double";
                        readMethod = "SunSpecNullablePrimitives.ReadDoubleBigEndian";
                        writeMethodFormat = $"SunSpecNullablePrimitives.WriteDoubleBigEndian({{0}}, ({clrType}{{1}}){descaledValue})";
                        break;
                    case PointType.Acc16:
                    case PointType.Count:
                        clrType = "UInt16";
                        readMethod = $"SunSpecNullablePrimitives.ReadUInt16BigEndian";
                        writeMethodFormat = $"SunSpecNullablePrimitives.WriteUInt16BigEndian({{0}}, ({clrType}{{1}}){descaledValue})";
                        break;
                    case PointType.Acc32:
                        clrType = "UInt32";
                        readMethod = $"SunSpecNullablePrimitives.ReadUInt32BigEndian";
                        writeMethodFormat = $"SunSpecNullablePrimitives.WriteUInt32BigEndian({{0}}, ({clrType}{{1}}){descaledValue})";
                        break;
                    case PointType.Acc64:
                    case PointType.Eui48:
                        clrType = "UInt64";
                        readMethod = $"SunSpecNullablePrimitives.ReadUInt64BigEndian";
                        writeMethodFormat = $"SunSpecNullablePrimitives.WriteUInt64BigEndian({{0}}, ({clrType}{{1}}){descaledValue})";
                        break;
                    case PointType.String:
                        clrType = "string";
                        readMethod = "Encoding.UTF8.GetString";
                        writeMethodFormat = $"if (value.Length > {point.Size * 2}) throw new ArgumentOutOfRangeException(\"Value for {pointName} is greater than the maximum permitted length ({point.Size * 2} characters).\"); Encoding.UTF8.GetBytes(value, {{0}});";
                        break;
                    case PointType.Pad:
                        paddingOffsets.Add(currentOffset);
                        continue;
                    case PointType.SunSsf:
                        continue;
                    default:
                        throw new NotSupportedException($"Type {point.Type} of field {point.Label} is not supported.");
                }
                writer.WriteLine();
                if (!String.IsNullOrEmpty(point.Description))
                {
                    writer.WriteLine("\t/// <summary>");
                    writer.WriteLine($"\t/// {point.Description}");
                    writer.WriteLine("\t/// </summary>");
                    if (!String.IsNullOrEmpty(point.Units) || point.Standards.Count > 0)
                    {
                        writer.WriteLine("\t/// <remarks>");
                        if (!String.IsNullOrEmpty(point.Units))
                        {
                            writer.WriteLine($"\t/// Unit: {point.Units}");
                        }
                        if (point.Standards.Count > 0)
                        {
                            writer.WriteLine($"\t/// Standards: {String.Join(", ", point.Standards)}");
                        }
                        writer.WriteLine("\t/// </remarks>");
                    }
                    if (!String.IsNullOrEmpty(point.Label))
                    {
                        writer.WriteLine($"\t[DisplayName(\"{point.Label}\")]");
                    }
                    writer.WriteLine($"\t[Description(\"{point.Description.Replace("\"", "\\\"")}\")]");
                }
                bool isNullable = point.Type != PointType.String;
                if (point.IsMandatory || countNames.Contains(point.Name))
                {
                    isNullable = false;
                    writer.WriteLine("\t[Required]");
                    // revert writer
                    readMethod = readMethod.Replace("SunSpecNullablePrimitives", "BinaryPrimitives");
                    writeMethodFormat = writeMethodFormat.Replace("SunSpecNullablePrimitives", "BinaryPrimitives");
                }
                if (!point.IsReadWrite)
                {
                    writer.WriteLine("\t[ReadOnly(true)]");
                }
                if (point.Type == PointType.String)
                {
                    writer.WriteLine($"\t[MaxLength({point.Size * 2})]");
                }
                if (!String.IsNullOrEmpty(scaler))
                {
                    // assume all scaled typed are doubles
                    clrType = "double";
                }
                if (isNullable)
                {
                    // check if read method contains a cast; if it does, need to make it nullable
                    if (readMethod[0] == '(')
                    {
                        readMethod = readMethod.Replace($"({clrType})", $"({clrType}?)");
                    }
                    clrType += "?";
                    nullableProperties.Add(pointName);
                }
                writer.WriteLine($"\tpublic {clrType} {pointName}");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\tget {{ return {readMethod}(_buffer.Span.Slice({currentOffset * 2})){scaler}; }}");
                writer.WriteLine($"\t\tset {{ {String.Format(writeMethodFormat, $"_buffer.Span.Slice({currentOffset * 2})", isNullable ? "?" : String.Empty)}; }}");
                writer.WriteLine("\t}");
                if (point.IsReadWrite)
                {
                    // create Changed event for editable values
                    writer.WriteLine();
                    writer.WriteLine("#nullable enable");
                    writer.WriteLine($"\tpublic event EventHandler? {pointName}Changed;");
                    writer.WriteLine("#nullable disable");

                    writeablePointNamesByOffset.Add(currentOffset, pointName);
                }
            }

            writer.WriteLine();
            writer.WriteLine("\tpublic void NotifyValueChanged(int relativeRegisterId)");
            writer.WriteLine("\t{");
            if (writeablePointNamesByOffset.Count > 0)
            {
                writer.WriteLine("\t\tswitch (relativeRegisterId)");
                writer.WriteLine("\t\t{");
                foreach (int o in writeablePointNamesByOffset.Keys)
                {
                    string name = writeablePointNamesByOffset[o];
                    writer.WriteLine($"\t\t\tcase {o}:");
                    writer.WriteLine($"\t\t\t\t{name}Changed?.Invoke(this, EventArgs.Empty);");
                    writer.WriteLine("\t\t\t\tbreak;");
                }
                writer.WriteLine("\t\t}");
            }
            writer.WriteLine("\t}");

            writer.WriteLine();
            writer.WriteLine("\tinternal void Initialise()");
            writer.WriteLine("\t{");
            foreach (string pointName in nullableProperties)
            {
                writer.WriteLine($"\t\t{pointName} = null;");
            }
            // all padding registers should be set to 0x8000
            foreach (int paddingOffset in paddingOffsets)
            {
                writer.WriteLine($"\t\tSunSpecNullablePrimitives.WritePadNull(_buffer.Span.Slice({paddingOffset * 2}));");
            }
            writer.WriteLine("\t}");

            // type to hold scale factors
            if (scaleFactors.Count > 0)
            {
                appendixWriter.WriteLine($"public class {className}ScaleFactors");
                appendixWriter.WriteLine("{");
                appendixWriter.WriteLine("\tprivate readonly Memory<byte> _buffer;");
                appendixWriter.WriteLine();
                appendixWriter.WriteLine($"\tinternal {className}ScaleFactors(Memory<byte> buffer)");
                appendixWriter.WriteLine("\t{");
                appendixWriter.WriteLine("\t\t_buffer = buffer;");
                appendixWriter.WriteLine("\t}");
                foreach ((Point point, int currentOffset) in scaleFactors)
                {
                    string name = point.Name.Replace("_SF", String.Empty);
                    appendixWriter.WriteLine();
                    appendixWriter.WriteLine($"\tpublic double {name}");
                    appendixWriter.WriteLine("\t{");
                    appendixWriter.WriteLine($"\t\tget {{ return Math.Pow(10, BinaryPrimitives.ReadInt16BigEndian(_buffer.Span.Slice({currentOffset * 2}))); }}");
                    appendixWriter.WriteLine($"\t\tset {{ BinaryPrimitives.WriteInt16BigEndian(_buffer.Span.Slice({currentOffset * 2}), (short)Math.Log10(value)); }}");
                    appendixWriter.WriteLine("\t}");
                }
                appendixWriter.WriteLine("}");
                appendixWriter.WriteLine();
            }

            // any other types
            foreach (string line in appendicesByTypeName.Values.SelectMany(x => x))
            {
                appendixWriter.WriteLine(line);
            }

            return offset;
        }

        private static bool TryCreateEnum(Point point, Func<PointType, string?> baseTypeSelector, string valueFormat,
            Dictionary<string, List<string>> appendicesByTypeName,
            ref string clrType, out string readMethod, out string writeMethodFormat)
        {
            string? baseType = baseTypeSelector(point.Type);
            if (baseType is null)
            {
                readMethod = String.Empty;
                writeMethodFormat = String.Empty;
                return false;
            }

            readMethod = $"SunSpecNullablePrimitives.Read{baseType}BigEndian";
            writeMethodFormat = $"SunSpecNullablePrimitives.Write{baseType}BigEndian({{0}}, ({baseType}{{1}})value)";
            if (point.Symbols.Count > 0)
            {
                readMethod = $"({clrType}){readMethod}"; // cast to type
                List<string> appendices =
                [
                    $"public enum {clrType} : {baseType}",
                    "{",
                ];
                foreach (Symbol symbol in point.Symbols)
                {
                    appendices.Add($"\t{ConvertName(symbol.Name, false)} = {String.Format(valueFormat, symbol.Value)},");
                }
                appendices.Add("}");
                appendices.Add(String.Empty);
                if (!appendicesByTypeName.TryAdd(clrType, appendices))
                {
                    if (!appendices.SequenceEqual(appendicesByTypeName[clrType]))
                    {
                        throw new ArgumentException($"Enum {clrType} redefined with different values.");
                    }
                }
            }
            else
            {
                clrType = baseType;
            }

            return true;
        }

        private static string ToFieldName(string name)
        {
            Span<char> result = name.ToCharArray();
            result[0] = Char.ToLower(name[0]);
            return new string(result);
        }

        private static string ConvertName(string name, bool typeName)
        {
            ReadOnlySpan<char> input = name;
            Span<char> output = new char[input.Length];
            int o = 0;
            bool upper = true;
            for (int i = 0; i < input.Length; i++)
            {
                char c = input[i];
                if (Char.IsAsciiLetterOrDigit(c))
                {
                    output[o++] = upper ? Char.ToUpper(c) : typeName ? c : Char.ToLower(c);
                    upper = false;
                }
                else
                {
                    upper = true;
                }
            }
            return new string(output.Slice(0, o));
        }
    }
}
